(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{569:function(t,v,e){"use strict";e.r(v);var a=e(6),_=Object(a.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"对-mvvm-的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对-mvvm-的理解"}},[t._v("#")]),t._v(" 对 MVVM 的理解")]),t._v(" "),e("ul",[e("li",[t._v("Model-View-ViewModel 的缩写，Model 代表数据模型，View 代表 UI 组件,ViewModel 将 Model 和 View 关联起来。")]),t._v(" "),e("li",[t._v("数据会绑定到 viewModel 层并自动将数据渲染到页面中，视图变化的时候会通知 viewModel 层更新数据")])]),t._v(" "),e("h2",{attrs:{id:"vue2-x-响应式数据-双向绑定原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue2-x-响应式数据-双向绑定原理"}},[t._v("#")]),t._v(" Vue2.X 响应式数据 / 双向绑定原理")]),t._v(" "),e("ul",[e("li",[t._v("Vue 数据双向绑定主要指： "),e("strong",[t._v("数据变化更新视图，视图变化更新数据")]),t._v(" 。")]),t._v(" "),e("li",[t._v("View 变化更新 Data，可以通过事件监听的方式来实现。")]),t._v(" "),e("li",[t._v("Vue 数据双向绑定的工作主要是如何根据 Data 变化更新 View。")])]),t._v(" "),e("h2",{attrs:{id:"computed-和-watch-的区别-和运用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch-的区别-和运用场景"}},[t._v("#")]),t._v(" computed 和 watch 的区别 和运用场景")]),t._v(" "),e("h3",{attrs:{id:"区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[t._v("#")]),t._v(" 区别")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("computed：是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有"),e("strong",[t._v("它依赖的属性值发生改变")]),t._v("，下一次获取 computed 的值时才会重新计算 computed 的值。")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("watch：没有缓存性")]),t._v("，更多的是「观察」的作用，类似于某些数据的"),e("strong",[t._v("监听回调")]),t._v(" ，每当监听的数据变化时都会执行回调进行后续操作；当我们需要深度监听对象中的属性时，可以打开 deep：true 选项，这样便会对对象中的每一项进行监听。")])])]),t._v(" "),e("h3",{attrs:{id:"运用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#运用场景"}},[t._v("#")]),t._v(" 运用场景")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算。")])]),t._v(" "),e("li",[e("p",[t._v("当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。")])])]),t._v(" "),e("h2",{attrs:{id:"vue2-x-组件之间的通信方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue2-x-组件之间的通信方式"}},[t._v("#")]),t._v(" Vue2.X 组件之间的通信方式")]),t._v(" "),e("h3",{attrs:{id:"父子组件通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#父子组件通信"}},[t._v("#")]),t._v(" 父子组件通信")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("事件机制")]),t._v(" "),e("ul",[e("li",[t._v("父 -> 子 props")]),t._v(" "),e("li",[t._v("子 -> 父 $on、$emit")])])]),t._v(" "),e("li",[e("p",[t._v("获取父子组件的实例")]),t._v(" "),e("ul",[e("li",[t._v("$parent")]),t._v(" "),e("li",[t._v("$children")])])]),t._v(" "),e("li",[e("p",[t._v("Ref 获取实例的方式调用组件的属性或者方法")])]),t._v(" "),e("li",[e("p",[t._v("Provide、inject (不推荐使用，组件库时很常用)")])])]),t._v(" "),e("h3",{attrs:{id:"兄弟组件的通信、跨级组件的通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#兄弟组件的通信、跨级组件的通信"}},[t._v("#")]),t._v(" 兄弟组件的通信、跨级组件的通信")]),t._v(" "),e("ul",[e("li",[t._v("Vuex")])]),t._v(" "),e("h2",{attrs:{id:"v-if-和-v-show-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-if-和-v-show-的区别"}},[t._v("#")]),t._v(" V-if 和 V-show 的区别")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("当条件不成立时，v-if 不会渲染 DOM 元素，v-show 操作的是样式(display)，切换当前 DOM 的显示和隐藏。")])]),t._v(" "),e("li",[e("p",[t._v("v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；")])]),t._v(" "),e("li",[e("p",[t._v("v-show 则适用于需要非常频繁切换条件的场景。")])])])])}),[],!1,null,null,null);v.default=_.exports}}]);